<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API References · TextAnalysis</title><link rel="canonical" href="https://juliatext.github.io/TextAnalysis.jl/stable/APIReference/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/custom.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><h1>TextAnalysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../documents/">Documents</a></li><li><a class="toctext" href="../corpus/">Corpus</a></li><li><a class="toctext" href="../features/">Features</a></li><li><a class="toctext" href="../semantic/">Semantic Analysis</a></li><li><a class="toctext" href="../classify/">Classifier</a></li><li><a class="toctext" href="../example/">Extended Example</a></li><li><a class="toctext" href="../evaluation_metrics/">Evaluation Metrics</a></li><li><a class="toctext" href="../crf/">Conditional Random Fields</a></li><li><a class="toctext" href="../ner/">Named Entity Recognition</a></li><li><a class="toctext" href="../ULMFiT/">ULMFiT</a></li><li><a class="toctext" href="../LM/">Statistical Language Model</a></li><li class="current"><a class="toctext" href>API References</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API References</a></li></ul><a class="edit-page" href="https://github.com/JuliaText/TextAnalysis.jl/blob/master/docs/src/APIReference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API References</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-References-1" href="#API-References-1">API References</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.DirectoryCorpus-Tuple{AbstractString}" href="#TextAnalysis.DirectoryCorpus-Tuple{AbstractString}"><code>TextAnalysis.DirectoryCorpus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DirectoryCorpus(dirname::AbstractString)</code></pre><p>Construct a Corpus from a directory of text files.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L40-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.author!-Tuple{AbstractDocument,AbstractString}" href="#TextAnalysis.author!-Tuple{AbstractDocument,AbstractString}"><code>TextAnalysis.author!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">author!(doc, author)</code></pre><p>Set the author metadata of doc to <code>author</code>.</p><p>See also: <a href="#TextAnalysis.author-Tuple{AbstractDocument}"><code>author</code></a>, <a href="#TextAnalysis.authors-Tuple{Corpus}"><code>authors</code></a>, <a href="#TextAnalysis.authors!-Tuple{Corpus,Array{String,1}}"><code>authors!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L72-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.author-Tuple{AbstractDocument}" href="#TextAnalysis.author-Tuple{AbstractDocument}"><code>TextAnalysis.author</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">author(doc)</code></pre><p>Return the author metadata for <code>doc</code>.</p><p>See also: <a href="#TextAnalysis.author!-Tuple{AbstractDocument,AbstractString}"><code>author!</code></a>, <a href="#TextAnalysis.authors-Tuple{Corpus}"><code>authors</code></a>, <a href="#TextAnalysis.authors!-Tuple{Corpus,Array{String,1}}"><code>authors!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L21-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.authors!-Tuple{Corpus,Array{String,1}}" href="#TextAnalysis.authors!-Tuple{Corpus,Array{String,1}}"><code>TextAnalysis.authors!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">authors!(crps, athrs)
authors!(crps, athr)</code></pre><p>Set the authors of the documents in <code>crps</code> to the <code>athrs</code>, respectively.</p><p>See also: <a href="#TextAnalysis.authors-Tuple{Corpus}"><code>authors</code></a>, <a href="#TextAnalysis.author!-Tuple{AbstractDocument,AbstractString}"><code>author!</code></a>, <a href="#TextAnalysis.author-Tuple{AbstractDocument}"><code>author</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L170-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.authors-Tuple{Corpus}" href="#TextAnalysis.authors-Tuple{Corpus}"><code>TextAnalysis.authors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">authors(crps)</code></pre><p>Return the authors for each document in <code>crps</code>.</p><p>See also: <a href="#TextAnalysis.authors!-Tuple{Corpus,Array{String,1}}"><code>authors!</code></a>, <a href="#TextAnalysis.author-Tuple{AbstractDocument}"><code>author</code></a>, <a href="#TextAnalysis.author!-Tuple{AbstractDocument,AbstractString}"><code>author!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L113-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.coom-Tuple{CooMatrix}" href="#TextAnalysis.coom-Tuple{CooMatrix}"><code>TextAnalysis.coom</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">coom(c::CooMatrix)</code></pre><p>Access the co-occurrence matrix field <code>coom</code> of a <code>CooMatrix</code> <code>c</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/coom.jl#L151-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.coom-Union{Tuple{Any}, Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:AbstractFloat" href="#TextAnalysis.coom-Union{Tuple{Any}, Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:AbstractFloat"><code>TextAnalysis.coom</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">coom(entity, eltype=DEFAULT_FLOAT_TYPE [;window=5, normalize=true])</code></pre><p>Access the co-occurrence matrix of the <code>CooMatrix</code> associated with the <code>entity</code>. The <code>CooMatrix{T}</code> will first have to be created in order for the actual matrix to be accessed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/coom.jl#L158-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.dtm-Tuple{DocumentTermMatrix,Symbol}" href="#TextAnalysis.dtm-Tuple{DocumentTermMatrix,Symbol}"><code>TextAnalysis.dtm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dtm(crps::Corpus)
dtm(d::DocumentTermMatrix)
dtm(d::DocumentTermMatrix, density::Symbol)</code></pre><p>Creates a simple sparse matrix of DocumentTermMatrix object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; dtm(DocumentTermMatrix(crps))
2×6 SparseArrays.SparseMatrixCSC{Int64,Int64} with 10 stored entries:
  [1, 1]  =  1
  [2, 1]  =  1
  [1, 2]  =  2
  [2, 3]  =  2
  [1, 4]  =  1
  [2, 4]  =  1
  [1, 5]  =  1
  [2, 5]  =  1
  [1, 6]  =  1
  [2, 6]  =  1

julia&gt; dtm(DocumentTermMatrix(crps), :dense)
2×6 Array{Int64,2}:
 1  2  0  1  1  1
 1  0  2  1  1  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L92-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.dtv-Union{Tuple{T}, Tuple{AbstractDocument,Dict{T,Int64}}} where T" href="#TextAnalysis.dtv-Union{Tuple{T}, Tuple{AbstractDocument,Dict{T,Int64}}} where T"><code>TextAnalysis.dtv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">dtv(d::AbstractDocument, lex::Dict{String, Int})</code></pre><p>Produce a single row of a DocumentTermMatrix.</p><p>Individual documents do not have a lexicon associated with them, we have to pass in a lexicon as an additional argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dtv(crps[1], lexicon(crps))
1×6 Array{Int64,2}:
 1  2  0  1  1  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L171-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.everygram-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString" href="#TextAnalysis.everygram-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractString"><code>TextAnalysis.everygram</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">everygram(seq::Vector{T}; min_len::Int=1, max_len::Int=-1)where { T &lt;: AbstractString}</code></pre><p>Return all possible ngrams generated from sequence of items, as an Array{String,1}</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; seq = [&quot;To&quot;,&quot;be&quot;,&quot;or&quot;,&quot;not&quot;]
julia&gt; a = everygram(seq,min_len=1, max_len=-1)
 10-element Array{Any,1}:
  &quot;or&quot;          
  &quot;not&quot;         
  &quot;To&quot;          
  &quot;be&quot;                  
  &quot;or not&quot; 
  &quot;be or&quot;       
  &quot;be or not&quot;   
  &quot;To be or&quot;    
  &quot;To be or not&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/preprocessing.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.fit!-Tuple{NaiveBayesClassifier,AbstractArray{T,1} where T&lt;:Integer,Any}" href="#TextAnalysis.fit!-Tuple{NaiveBayesClassifier,AbstractArray{T,1} where T&lt;:Integer,Any}"><code>TextAnalysis.fit!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fit!(model::NaiveBayesClassifier, str, class)
fit!(model::NaiveBayesClassifier, ::Features, class)
fit!(model::NaiveBayesClassifier, ::StringDocument, class)</code></pre><p>Fit the weights for the model on the input data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L83-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.fit!-Tuple{PerceptronTagger,Array{Array{Tuple{String,String},1},1},String,Integer}" href="#TextAnalysis.fit!-Tuple{PerceptronTagger,Array{Array{Tuple{String,String},1},1},String,Integer}"><code>TextAnalysis.fit!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">fit!(::PerceptronTagger, sentences::Vector{Vector{Tuple{String, String}}}, save_loc::String, nr_iter::Integer)</code></pre><p>Used for training a new model or can be used for training an existing model by using pretrained weigths and classes</p><p>Contains main training loop for number of epochs. After training weights, tagdict and classes are stored in the specified location.</p><p><strong>Arguments:</strong></p><ul><li><code>::PerceptronTagger</code> : Input PerceptronTagger model</li><li><code>sentences::Vector{Vector{Tuple{String, String}}}</code> : Array of the all token seqeunces with target POS tag</li><li><code>save_loc::String</code> : To specify the saving location</li><li><code>nr_iter::Integer</code> : Total number of training iterations for given sentences(or number of epochs)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L323-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.frequent_terms" href="#TextAnalysis.frequent_terms"><code>TextAnalysis.frequent_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frequent_terms(crps, alpha=0.95)</code></pre><p>Find the frequent terms from Corpus, occuring more than <code>alpha</code> percentage of the documents.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; crps = Corpus([StringDocument(&quot;This is Document 1&quot;),
                      StringDocument(&quot;This is Document 2&quot;)])
A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s
Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens
julia&gt; frequent_terms(crps)
3-element Array{String,1}:
 &quot;is&quot;
 &quot;This&quot;
 &quot;Document&quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_frequent_terms!"><code>remove_frequent_terms!</code></a>, <a href="#TextAnalysis.sparse_terms"><code>sparse_terms</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L283-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.hash_dtm-Tuple{Corpus,TextHashFunction}" href="#TextAnalysis.hash_dtm-Tuple{Corpus,TextHashFunction}"><code>TextAnalysis.hash_dtm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash_dtm(crps::Corpus)
hash_dtm(crps::Corpus, h::TextHashFunction)</code></pre><p>Represents a Corpus as a Matrix with N entries.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L242-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.hash_dtv-Tuple{AbstractDocument,TextHashFunction}" href="#TextAnalysis.hash_dtv-Tuple{AbstractDocument,TextHashFunction}"><code>TextAnalysis.hash_dtv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hash_dtv(d::AbstractDocument)
hash_dtv(d::AbstractDocument, h::TextHashFunction)</code></pre><p>Represents a document as a vector with N entries.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])

julia&gt; h = TextHashFunction(10)
TextHashFunction(hash, 10)

julia&gt; hash_dtv(crps[1], h)
1×10 Array{Int64,2}:
 0  2  0  0  1  3  0  0  0  0

julia&gt; hash_dtv(crps[1])
1×100 Array{Int64,2}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L206-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.index_hash-Tuple{AbstractString,TextHashFunction}" href="#TextAnalysis.index_hash-Tuple{AbstractString,TextHashFunction}"><code>TextAnalysis.index_hash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">index_hash(str, TextHashFunc)</code></pre><p>Shows mapping of string to integer.</p><p>Parameters: 	-  str		   = Max index used for hashing (default 100)  	-  TextHashFunc    = TextHashFunction type object</p><pre><code class="language-julia-repl">julia&gt; h = TextHashFunction(10)
TextHashFunction(hash, 10)

julia&gt; index_hash(&quot;a&quot;, h)
8

julia&gt; index_hash(&quot;b&quot;, h)
7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/hash.jl#L51-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.inverse_index-Tuple{Corpus}" href="#TextAnalysis.inverse_index-Tuple{Corpus}"><code>TextAnalysis.inverse_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">inverse_index(crps::Corpus)</code></pre><p>Shows the inverse index of a corpus.</p><p>If we are interested in a specific term, we often want to know which documents in a corpus contain that term. The inverse index tells us this and therefore provides a simplistic sort of search algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L235-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.language!-Tuple{AbstractDocument,Languages.Language}" href="#TextAnalysis.language!-Tuple{AbstractDocument,Languages.Language}"><code>TextAnalysis.language!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">language!(doc, lang::Language)</code></pre><p>Set the language of <code>doc</code> to <code>lang</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = StringDocument(&quot;String Document 1&quot;)

julia&gt; language!(d, Languages.Spanish())

julia&gt; d.metadata.language
Languages.Spanish()</code></pre><p>See also: <a href="#TextAnalysis.language-Tuple{AbstractDocument}"><code>language</code></a>, <a href="#TextAnalysis.languages-Tuple{Corpus}"><code>languages</code></a>, <a href="#TextAnalysis.languages!-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T&lt;:Languages.Language"><code>languages!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L51-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.language-Tuple{AbstractDocument}" href="#TextAnalysis.language-Tuple{AbstractDocument}"><code>TextAnalysis.language</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">language(doc)</code></pre><p>Return the language metadata for <code>doc</code>.</p><p>See also: <a href="#TextAnalysis.language!-Tuple{AbstractDocument,Languages.Language}"><code>language!</code></a>, <a href="#TextAnalysis.languages-Tuple{Corpus}"><code>languages</code></a>, <a href="#TextAnalysis.languages!-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T&lt;:Languages.Language"><code>languages!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.languages!-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T&lt;:Languages.Language" href="#TextAnalysis.languages!-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T&lt;:Languages.Language"><code>TextAnalysis.languages!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">languages!(crps, langs::Vector{Language})
languages!(crps, lang::Language)</code></pre><p>Update languages of documents in a Corpus.</p><p>If the input is a Vector, then language of the <code>i</code>th document is set to the <code>i</code>th element in the vector, respectively. However, the number of documents must equal the length of vector.</p><p>See also: <a href="#TextAnalysis.languages-Tuple{Corpus}"><code>languages</code></a>, <a href="#TextAnalysis.language!-Tuple{AbstractDocument,Languages.Language}"><code>language!</code></a>, <a href="#TextAnalysis.language-Tuple{AbstractDocument}"><code>language</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L153-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.languages-Tuple{Corpus}" href="#TextAnalysis.languages-Tuple{Corpus}"><code>TextAnalysis.languages</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">languages(crps)</code></pre><p>Return the languages for each document in <code>crps</code>.</p><p>See also: <a href="#TextAnalysis.languages!-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T&lt;:Languages.Language"><code>languages!</code></a>, <a href="#TextAnalysis.language-Tuple{AbstractDocument}"><code>language</code></a>, <a href="#TextAnalysis.language!-Tuple{AbstractDocument,Languages.Language}"><code>language!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L104-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lda-Tuple{DocumentTermMatrix,Int64,Int64,Float64,Float64}" href="#TextAnalysis.lda-Tuple{DocumentTermMatrix,Int64,Int64,Float64,Float64}"><code>TextAnalysis.lda</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ϕ, θ = lda(dtm::DocumentTermMatrix, ntopics::Int, iterations::Int, α::Float64, β::Float64)</code></pre><p>Perform <a href="https://en.wikipedia.org/wiki/Latent_Dirichlet_allocation">Latent Dirichlet allocation</a>.</p><p><strong>Arguments</strong></p><ul><li><code>α</code> Dirichlet dist. hyperparameter for topic distribution per document. <code>α&lt;1</code> yields a sparse topic mixture for each document. <code>α&gt;1</code> yields a more uniform topic mixture for each document.</li><li><code>β</code> Dirichlet dist. hyperparameter for word distribution per topic. <code>β&lt;1</code> yields a sparse word mixture for each topic. <code>β&gt;1</code> yields a more uniform word mixture for each topic.</li></ul><p><strong>Return values</strong></p><ul><li><code>ϕ</code>: <code>ntopics × nwords</code> Sparse matrix of probabilities s.t. <code>sum(ϕ, 1) == 1</code></li><li><code>θ</code>: <code>ntopics × ndocs</code> Dense matrix of probabilities s.t. <code>sum(θ, 1) == 1</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/lda.jl#L24-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lexical_frequency-Tuple{Corpus,AbstractString}" href="#TextAnalysis.lexical_frequency-Tuple{Corpus,AbstractString}"><code>TextAnalysis.lexical_frequency</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lexical_frequency(crps::Corpus, term::AbstractString)</code></pre><p>Tells us how often a term occurs across all of the documents.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L220-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lexicon-Tuple{Corpus}" href="#TextAnalysis.lexicon-Tuple{Corpus}"><code>TextAnalysis.lexicon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lexicon(crps::Corpus)</code></pre><p>Shows the lexicon of the corpus.</p><p>Lexicon of a corpus consists of all the terms that occur in any document in the corpus.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;Name Foo&quot;),
                          StringDocument(&quot;Name Bar&quot;)])
A Corpus with 2 documents:
* 2 StringDocument&#39;s
* 0 FileDocument&#39;s
* 0 TokenDocument&#39;s
* 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens

julia&gt; lexicon(crps)
Dict{String,Int64} with 0 entries</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L171-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lexicon_size-Tuple{Corpus}" href="#TextAnalysis.lexicon_size-Tuple{Corpus}"><code>TextAnalysis.lexicon_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lexicon_size(crps::Corpus)</code></pre><p>Tells the total number of terms in a lexicon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L213-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lookup-Union{Tuple{T}, Tuple{Vocabulary,Array{T,1}}} where T&lt;:AbstractString" href="#TextAnalysis.lookup-Union{Tuple{T}, Tuple{Vocabulary,Array{T,1}}} where T&lt;:AbstractString"><code>TextAnalysis.lookup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>lookup a sequence or words in the vocabulary</p><p>Return an Array of String</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/vocab.jl#L99-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.lsa-Tuple{DocumentTermMatrix}" href="#TextAnalysis.lsa-Tuple{DocumentTermMatrix}"><code>TextAnalysis.lsa</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lsa(dtm::DocumentTermMatrix)
lsa(crps::Corpus)</code></pre><p>Performs Latent Semantic Analysis or LSA on a corpus.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/lsa.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.ngrams-Tuple{NGramDocument,Integer}" href="#TextAnalysis.ngrams-Tuple{NGramDocument,Integer}"><code>TextAnalysis.ngrams</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ngrams(ngd::NGramDocument, n::Integer)
ngrams(d::AbstractDocument, n::Integer)
ngrams(d::NGramDocument)
ngrams(d::AbstractDocument)</code></pre><p>Access the document text as n-gram counts.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...

julia&gt; ngrams(sd)
 Dict{String,Int64} with 7 entries:
  &quot;or&quot;   =&gt; 1
  &quot;not&quot;  =&gt; 1
  &quot;to&quot;   =&gt; 1
  &quot;To&quot;   =&gt; 1
  &quot;be&quot;   =&gt; 1
  &quot;be..&quot; =&gt; 1
  &quot;.&quot;    =&gt; 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L280-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.padding_ngram-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}} where T&lt;:AbstractString" href="#TextAnalysis.padding_ngram-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}} where T&lt;:AbstractString"><code>TextAnalysis.padding_ngram</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">padding_ngram(word::Vector{T}, n=1; pad_left=false, pad_right=false, left_pad_symbol=&quot;&lt;s&gt;&quot;, right_pad_symbol =&quot;&lt;/s&gt;&quot;) where { T &lt;: AbstractString}</code></pre><p>padding _ngram is used to pad both left and right of sentence and out putting ngrmas of order n</p><p>It also pad the original input Array of string </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; example = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]

julia&gt; padding_ngrams(example,2,pad_left=true,pad_right=true)
 6-element Array{Any,1}:
  &quot;&lt;s&gt; 1&quot; 
  &quot;1 2&quot;   
  &quot;2 3&quot;   
  &quot;3 4&quot;   
  &quot;4 5&quot;   
  &quot;5 &lt;/s&gt;&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/preprocessing.jl#L36-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.predict-Tuple{NaiveBayesClassifier,AbstractArray{T,1} where T&lt;:Integer}" href="#TextAnalysis.predict-Tuple{NaiveBayesClassifier,AbstractArray{T,1} where T&lt;:Integer}"><code>TextAnalysis.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">predict(::NaiveBayesClassifier, str)
predict(::NaiveBayesClassifier, ::Features)
predict(::NaiveBayesClassifier, ::StringDocument)</code></pre><p>Predict probabilities for each class on the input Features or String.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L106-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.predict-Tuple{PerceptronTagger,Array{String,1}}" href="#TextAnalysis.predict-Tuple{PerceptronTagger,Array{String,1}}"><code>TextAnalysis.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">predict(::PerceptronTagger, tokens)
predict(::PerceptronTagger, sentence)</code></pre><p>Used for predicting the tags for given sentence or array of tokens</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L281-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.predict-Tuple{TextAnalysis.AveragePerceptron,Any}" href="#TextAnalysis.predict-Tuple{TextAnalysis.AveragePerceptron,Any}"><code>TextAnalysis.predict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Predicting the class using current weights by doing Dot-product of features and weights and return the scores</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L48-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.prepare!-Tuple{Corpus,UInt32}" href="#TextAnalysis.prepare!-Tuple{Corpus,UInt32}"><code>TextAnalysis.prepare!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">prepare!(doc, flags)
prepare!(crps, flags)</code></pre><p>Preprocess document or corpus based on the input flags.</p><p><strong>List of Flags</strong></p><ul><li>strip_patterns</li><li>strip<em>corrupt</em>utf8</li><li>strip_case</li><li>stem_words</li><li>tag<em>part</em>of_speech</li><li>strip_whitespace</li><li>strip_punctuation</li><li>strip_numbers</li><li>strip<em>non</em>letters</li><li>strip<em>indefinite</em>articles</li><li>strip<em>definite</em>articles</li><li>strip_articles</li><li>strip_prepositions</li><li>strip_pronouns</li><li>strip_stopwords</li><li>strip<em>sparse</em>terms</li><li>strip<em>frequent</em>terms</li><li>strip<em>html</em>tags</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; doc = StringDocument(&quot;This is a document of mine&quot;)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: This is a document of mine
julia&gt; prepare!(doc, strip_pronouns | strip_articles)
julia&gt; text(doc)
&quot;This is   document of &quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L368-L404">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_case!-Tuple{FileDocument}" href="#TextAnalysis.remove_case!-Tuple{FileDocument}"><code>TextAnalysis.remove_case!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_case!(doc)
remove_case!(crps)</code></pre><p>Convert the text of <code>doc</code> or <code>crps</code> to lowercase. Does not support <code>FileDocument</code> or <code>crps</code> containing <code>FileDocument</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; str = &quot;The quick brown fox jumps over the lazy dog&quot;
julia&gt; sd = StringDocument(str)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: The quick brown fox jumps over the lazy dog
julia&gt; remove_case!(sd)
julia&gt; sd.text
&quot;the quick brown fox jumps over the lazy dog&quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_case-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractString"><code>remove_case</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L95-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_case-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractString" href="#TextAnalysis.remove_case-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractString"><code>TextAnalysis.remove_case</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_case(str)</code></pre><p>Convert <code>str</code> to lowercase. See also: <a href="#TextAnalysis.remove_case!-Tuple{FileDocument}"><code>remove_case!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_corrupt_utf8!-Tuple{StringDocument}" href="#TextAnalysis.remove_corrupt_utf8!-Tuple{StringDocument}"><code>TextAnalysis.remove_corrupt_utf8!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_corrupt_utf8!(doc)
remove_corrupt_utf8!(crps)</code></pre><p>Remove corrupt UTF8 characters for <code>doc</code> or documents in <code>crps</code>. Does not support <code>FileDocument</code> or Corpus containing <code>FileDocument</code>. See also: <a href="#TextAnalysis.remove_corrupt_utf8-Tuple{AbstractString}"><code>remove_corrupt_utf8</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L50-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_corrupt_utf8-Tuple{AbstractString}" href="#TextAnalysis.remove_corrupt_utf8-Tuple{AbstractString}"><code>TextAnalysis.remove_corrupt_utf8</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_corrupt_utf8(str)</code></pre><p>Remove corrupt UTF8 characters in <code>str</code>. See also: <a href="#TextAnalysis.remove_corrupt_utf8!-Tuple{StringDocument}"><code>remove_corrupt_utf8!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_frequent_terms!" href="#TextAnalysis.remove_frequent_terms!"><code>TextAnalysis.remove_frequent_terms!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remove_frequent_terms!(crps, alpha=0.95)</code></pre><p>Remove terms in <code>crps</code>, occuring more than <code>alpha</code> percent of documents.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;This is Document 1&quot;),
                      StringDocument(&quot;This is Document 2&quot;)])
A Corpus with 2 documents:
* 2 StringDocument&#39;s
* 0 FileDocument&#39;s
* 0 TokenDocument&#39;s
* 0 NGramDocument&#39;s
Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens
julia&gt; remove_frequent_terms!(crps)
julia&gt; text(crps[1])
&quot;     1&quot;
julia&gt; text(crps[2])
&quot;     2&quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_sparse_terms!"><code>remove_sparse_terms!</code></a>, <a href="#TextAnalysis.frequent_terms"><code>frequent_terms</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L343-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_html_tags!-Tuple{AbstractDocument}" href="#TextAnalysis.remove_html_tags!-Tuple{AbstractDocument}"><code>TextAnalysis.remove_html_tags!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_html_tags!(doc::StringDocument)
remove_html_tags!(crps)</code></pre><p>Remove html tags from the <code>StringDocument</code> or documents <code>crps</code>. Does not work for documents other than <code>StringDocument</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; html_doc = StringDocument(
             &quot;
               &lt;html&gt;
                   &lt;head&gt;&lt;script language=&quot;javascript&quot;&gt;x = 20;&lt;/script&gt;&lt;/head&gt;
                   &lt;body&gt;
                       &lt;h1&gt;Hello&lt;/h1&gt;&lt;a href=&quot;world&quot;&gt;world&lt;/a&gt;
                   &lt;/body&gt;
               &lt;/html&gt;
             &quot;
            )
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet:  &lt;html&gt; &lt;head&gt;&lt;s
julia&gt; remove_html_tags!(html_doc)
julia&gt; strip(text(html_doc))
&quot;Hello world&quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_html_tags-Tuple{AbstractString}"><code>remove_html_tags</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L164-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_html_tags-Tuple{AbstractString}" href="#TextAnalysis.remove_html_tags-Tuple{AbstractString}"><code>TextAnalysis.remove_html_tags</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_html_tags(str)</code></pre><p>Remove html tags from <code>str</code>, including the style and script tags. See also: <a href="#TextAnalysis.remove_html_tags!-Tuple{AbstractDocument}"><code>remove_html_tags!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_patterns!-Tuple{FileDocument,Regex}" href="#TextAnalysis.remove_patterns!-Tuple{FileDocument,Regex}"><code>TextAnalysis.remove_patterns!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_patterns!(doc, rex::Regex)
remove_patterns!(crps, rex::Regex)</code></pre><p>Remove patterns matched by <code>rex</code> in document or Corpus. Does not modify <code>FileDocument</code> or Corpus containing <code>FileDocument</code>. See also: <a href="#TextAnalysis.remove_patterns-Tuple{AbstractString,Regex}"><code>remove_patterns</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L498-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_patterns-Tuple{AbstractString,Regex}" href="#TextAnalysis.remove_patterns-Tuple{AbstractString,Regex}"><code>TextAnalysis.remove_patterns</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_patterns(str, rex::Regex)</code></pre><p>Remove the part of str matched by rex. See also: <a href="#TextAnalysis.remove_patterns!-Tuple{FileDocument,Regex}"><code>remove_patterns!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L468-L472">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_sparse_terms!" href="#TextAnalysis.remove_sparse_terms!"><code>TextAnalysis.remove_sparse_terms!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remove_sparse_terms!(crps, alpha=0.05)</code></pre><p>Remove sparse terms in crps, occuring less than <code>alpha</code> percent of documents.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;This is Document 1&quot;),
                      StringDocument(&quot;This is Document 2&quot;)])
A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s
Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens
julia&gt; remove_sparse_terms!(crps, 0.5)
julia&gt; crps[1].text
&quot;This is Document &quot;
julia&gt; crps[2].text
&quot;This is Document &quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_frequent_terms!"><code>remove_frequent_terms!</code></a>, <a href="#TextAnalysis.sparse_terms"><code>sparse_terms</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L319-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_words!-Union{Tuple{T}, Tuple{Union{AbstractDocument, Corpus},Array{T,1}}} where T&lt;:AbstractString" href="#TextAnalysis.remove_words!-Union{Tuple{T}, Tuple{Union{AbstractDocument, Corpus},Array{T,1}}} where T&lt;:AbstractString"><code>TextAnalysis.remove_words!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_words!(doc, words::Vector{AbstractString})
remove_words!(crps, words::Vector{AbstractString})</code></pre><p>Remove the occurences of words from <code>doc</code> or <code>crps</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; str=&quot;The quick brown fox jumps over the lazy dog&quot;
julia&gt; sd=StringDocument(str);
julia&gt; remove_words = [&quot;fox&quot;, &quot;over&quot;]
julia&gt; remove_words!(sd, remove_words)
julia&gt; sd.text
&quot;the quick brown   jumps   the lazy dog&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L209-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.rouge_l_sentence" href="#TextAnalysis.rouge_l_sentence"><code>TextAnalysis.rouge_l_sentence</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rouge_l_sentence(references, candidate, β, average)</code></pre><p>Calculate the ROUGE-L score between <code>references</code> and <code>candidate</code> at sentence level.</p><p>See <a href="http://www.aclweb.org/anthology/W04-1013">Rouge: A package for automatic evaluation of summaries</a></p><p>See also: <a href="#TextAnalysis.rouge_n-Tuple{Any,Any,Any}"><code>rouge_n</code></a>, <a href="#TextAnalysis.rouge_l_summary"><code>rouge_l_summary</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/evaluation_metrics.jl#L32-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.rouge_l_summary" href="#TextAnalysis.rouge_l_summary"><code>TextAnalysis.rouge_l_summary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rouge_l_summary(references, candidate, β, average)</code></pre><p>Calculate the ROUGE-L score between <code>references</code> and <code>candidate</code> at summary level.</p><p>See <a href="http://www.aclweb.org/anthology/W04-1013">Rouge: A package for automatic evaluation of summaries</a></p><p>See also: <a href="#TextAnalysis.rouge_l_sentence"><code>rouge_l_sentence()</code></a>, <a href="#TextAnalysis.rouge_l_summary"><code>rouge_l_summary</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/evaluation_metrics.jl#L59-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.rouge_n-Tuple{Any,Any,Any}" href="#TextAnalysis.rouge_n-Tuple{Any,Any,Any}"><code>TextAnalysis.rouge_n</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rouge_n(references::Array{T}, candidate::AbstractString, n; avg::Bool, lang::Language) where T&lt;: AbstractString</code></pre><p>Compute n-gram recall between <code>candidate</code> and the <code>references</code> summaries.</p><p>See <a href="http://www.aclweb.org/anthology/W04-1013">Rouge: A package for automatic evaluation of summaries</a></p><p>See also: <a href="#TextAnalysis.rouge_l_sentence"><code>rouge_l_sentence</code></a>, <a href="#TextAnalysis.rouge_l_summary"><code>rouge_l_summary</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/evaluation_metrics.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.score" href="#TextAnalysis.score"><code>TextAnalysis.score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">score(m::MLE, temp_lm::DefaultDict, word::AbstractString, context::AbstractString)</code></pre><p>score is used to output probablity of word given that context in MLE</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L120-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.score" href="#TextAnalysis.score"><code>TextAnalysis.score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">score(m::InterpolatedLanguageModel, temp_lm::DefaultDict, word::AbstractString, context::AbstractString)</code></pre><p>score is used to output probablity of word given that context in InterpolatedLanguageModel</p><p>Apply Kneserney and WittenBell smoothing depending upon the sub-Type</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L179-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.score-Tuple{TextAnalysis.gammamodel,DataStructures.DefaultDict,Any,Any}" href="#TextAnalysis.score-Tuple{TextAnalysis.gammamodel,DataStructures.DefaultDict,Any,Any}"><code>TextAnalysis.score</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">score(m::gammamodel, temp_lm::DefaultDict, word::AbstractString, context::AbstractString)</code></pre><p>score is used to output probablity of word given that context </p><p>Add-one smoothing to Lidstone or Laplace(gammamodel) models</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L76-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.sparse_terms" href="#TextAnalysis.sparse_terms"><code>TextAnalysis.sparse_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sparse_terms(crps, alpha=0.05])</code></pre><p>Find the sparse terms from Corpus, occuring in less than <code>alpha</code> percentage of the documents.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; crps = Corpus([StringDocument(&quot;This is Document 1&quot;),
                      StringDocument(&quot;This is Document 2&quot;)])
A Corpus with 2 documents:
* 2 StringDocument&#39;s
* 0 FileDocument&#39;s
* 0 TokenDocument&#39;s
* 0 NGramDocument&#39;s
Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens
julia&gt; sparse_terms(crps, 0.5)
2-element Array{String,1}:
 &quot;1&quot;
 &quot;2&quot;</code></pre><p>See also: <a href="#TextAnalysis.remove_sparse_terms!"><code>remove_sparse_terms!</code></a>, <a href="#TextAnalysis.frequent_terms"><code>frequent_terms</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L248-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.standardize!-Union{Tuple{T}, Tuple{Corpus,Type{T}}} where T&lt;:AbstractDocument" href="#TextAnalysis.standardize!-Union{Tuple{T}, Tuple{Corpus,Type{T}}} where T&lt;:AbstractDocument"><code>TextAnalysis.standardize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">standardize!(crps::Corpus, ::Type{T}) where T &lt;: AbstractDocument</code></pre><p>Standardize the documents in a Corpus to a common type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;Document 1&quot;),
		              TokenDocument(&quot;Document 2&quot;),
		              NGramDocument(&quot;Document 3&quot;)])
A Corpus with 3 documents:
 * 1 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 1 TokenDocument&#39;s
 * 1 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens


julia&gt; standardize!(crps, NGramDocument)

julia&gt; crps
A Corpus with 3 documents:
 * 0 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 3 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L277-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.stem!-Tuple{AbstractDocument}" href="#TextAnalysis.stem!-Tuple{AbstractDocument}"><code>TextAnalysis.stem!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stem!(doc)
stem!(crps)</code></pre><p>Stems the document or documents in <code>crps</code> with a suitable stemmer.</p><p>Stemming cannot be done for <code>FileDocument</code> and Corpus made of these type of documents.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/stemmer.jl#L109-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.stem-Tuple{Stemmer,AbstractString}" href="#TextAnalysis.stem-Tuple{Stemmer,AbstractString}"><code>TextAnalysis.stem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stem(stemmer::Stemmer, str)
stem(stemmer::Stemmer, words::Array)</code></pre><p>Stem the input with the Stemming algorthm of <code>stemmer</code>.</p><p>See also: <a href="#TextAnalysis.stem!-Tuple{AbstractDocument}"><code>stem!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/stemmer.jl#L65-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.stemmer_types-Tuple{}" href="#TextAnalysis.stemmer_types-Tuple{}"><code>TextAnalysis.stemmer_types</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stemmer_types()</code></pre><p>List all the stemmer algorithms loaded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/stemmer.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.summarize-Tuple{AbstractDocument}" href="#TextAnalysis.summarize-Tuple{AbstractDocument}"><code>TextAnalysis.summarize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">summarize(doc [, ns])</code></pre><p>Summarizes the document and returns <code>ns</code> number of sentences. By default <code>ns</code> is set to the value 5.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; s = StringDocument(&quot;Assume this Short Document as an example. Assume this as an example summarizer. This has too foo sentences.&quot;)

julia&gt; summarize(s, ns=2)
2-element Array{SubString{String},1}:
 &quot;Assume this Short Document as an example.&quot;
 &quot;This has too foo sentences.&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/summarizer.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tag_scheme!-Tuple{Any,String,String}" href="#TextAnalysis.tag_scheme!-Tuple{Any,String,String}"><code>TextAnalysis.tag_scheme!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tag_scheme!(tags, current_scheme::String, new_scheme::String)</code></pre><p>Convert <code>tags</code> from <code>current_scheme</code> to <code>new_scheme</code>.</p><p>List of tagging schemes currently supported-</p><ul><li>BIO1 (BIO)</li><li>BIO2</li><li>BIOES</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tags = [&quot;I-LOC&quot;, &quot;O&quot;, &quot;I-PER&quot;, &quot;B-MISC&quot;, &quot;I-MISC&quot;, &quot;B-PER&quot;, &quot;I-PER&quot;, &quot;I-PER&quot;]

julia&gt; tag_scheme!(tags, &quot;BIO1&quot;, &quot;BIOES&quot;)

julia&gt; tags
8-element Array{String,1}:
 &quot;S-LOC&quot;
 &quot;O&quot;
 &quot;S-PER&quot;
 &quot;B-MISC&quot;
 &quot;E-MISC&quot;
 &quot;B-PER&quot;
 &quot;I-PER&quot;
 &quot;E-PER&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tagging_schemes.jl#L13-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.text-Tuple{FileDocument}" href="#TextAnalysis.text-Tuple{FileDocument}"><code>TextAnalysis.text</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">text(fd::FileDocument)
text(sd::StringDocument)
text(ngd::NGramDocument)</code></pre><p>Access the text of Document as a string.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...

julia&gt; text(sd)
&quot;To be or not to be...&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L192-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real" href="#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real"><code>TextAnalysis.tf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf!(dtm::SparseMatrixCSC{Real}, tf::SparseMatrixCSC{AbstractFloat})</code></pre><p>Overwrite <code>tf</code> with the term frequency of the <code>dtm</code>.</p><p><code>tf</code> should have the has same nonzeros as <code>dtm</code>.</p><p>See also: <a href="#TextAnalysis.tf-Tuple{DocumentTermMatrix}"><code>tf</code></a>, <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a>, <a href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L25-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf!-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T2,2}}} where T2&lt;:AbstractFloat where T1&lt;:Real" href="#TextAnalysis.tf!-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T2,2}}} where T2&lt;:AbstractFloat where T1&lt;:Real"><code>TextAnalysis.tf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf!(dtm::AbstractMatrix{Real}, tf::AbstractMatrix{AbstractFloat})</code></pre><p>Overwrite <code>tf</code> with the term frequency of the <code>dtm</code>.</p><p>Works correctly if <code>dtm</code> and <code>tf</code> are same matrix.</p><p>See also: <a href="#TextAnalysis.tf-Tuple{DocumentTermMatrix}"><code>tf</code></a>, <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a>, <a href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf-Tuple{DocumentTermMatrix}" href="#TextAnalysis.tf-Tuple{DocumentTermMatrix}"><code>TextAnalysis.tf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf(dtm::DocumentTermMatrix)
tf(dtm::SparseMatrixCSC{Real})
tf(dtm::Matrix{Real})</code></pre><p>Compute the <code>term-frequency</code> of the input.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
              StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; m = DocumentTermMatrix(crps)

julia&gt; tf(m)
2×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  0.166667
  [2, 1]  =  0.166667
  [1, 2]  =  0.333333
  [2, 3]  =  0.333333
  [1, 4]  =  0.166667
  [2, 4]  =  0.166667
  [1, 5]  =  0.166667
  [2, 5]  =  0.166667
  [1, 6]  =  0.166667
  [2, 6]  =  0.166667</code></pre><p>See also: <a href="#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real"><code>tf!</code></a>, <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a>, <a href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L57-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real" href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>TextAnalysis.tf_idf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf_idf!(dtm)</code></pre><p>Compute tf-idf for <code>dtm</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L160-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf_idf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real" href="#TextAnalysis.tf_idf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real"><code>TextAnalysis.tf_idf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf_idf!(dtm::SparseMatrixCSC{Real}, tfidf::SparseMatrixCSC{AbstractFloat})</code></pre><p>Overwrite <code>tfidf</code> with the tf-idf (Term Frequency - Inverse Doc Frequency) of the <code>dtm</code>.</p><p>The arguments must have same number of nonzeros.</p><p>See also: <a href="#TextAnalysis.tf-Tuple{DocumentTermMatrix}"><code>tf</code></a>, <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a>, <a href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L125-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf_idf!-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T2,2}}} where T2&lt;:AbstractFloat where T1&lt;:Real" href="#TextAnalysis.tf_idf!-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T2,2}}} where T2&lt;:AbstractFloat where T1&lt;:Real"><code>TextAnalysis.tf_idf!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf_idf!(dtm::AbstractMatrix{Real}, tf_idf::AbstractMatrix{AbstractFloat})</code></pre><p>Overwrite <code>tf_idf</code> with the tf-idf (Term Frequency - Inverse Doc Frequency) of the <code>dtm</code>.</p><p><code>dtm</code> and <code>tf-idf</code> must be matrices of same dimensions.</p><p>See also: <a href="#TextAnalysis.tf-Tuple{DocumentTermMatrix}"><code>tf</code></a>, <a href="#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real"><code>tf!</code></a> , <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L96-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}" href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>TextAnalysis.tf_idf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tf(dtm::DocumentTermMatrix)
tf(dtm::SparseMatrixCSC{Real})
tf(dtm::Matrix{Real})</code></pre><p>Compute <code>tf-idf</code> value (Term Frequency - Inverse Document Frequency) for the input.</p><p>In many cases, raw word counts are not appropriate for use because:</p><ul><li>Some documents are longer than other documents</li><li>Some words are more frequent than other words</li></ul><p>A simple workaround this can be done by performing <code>TF-IDF</code> on a <code>DocumentTermMatrix</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
              StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; m = DocumentTermMatrix(crps)

julia&gt; tf_idf(m)
2×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  0.0
  [2, 1]  =  0.0
  [1, 2]  =  0.231049
  [2, 3]  =  0.231049
  [1, 4]  =  0.0
  [2, 4]  =  0.0
  [1, 5]  =  0.0
  [2, 5]  =  0.0
  [1, 6]  =  0.0
  [2, 6]  =  0.0</code></pre><p>See also: <a href="#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseMatrixCSC{T,Ti} where Ti&lt;:Integer,SparseMatrixCSC{F,Ti} where Ti&lt;:Integer}} where F&lt;:AbstractFloat where T&lt;:Real"><code>tf!</code></a>, <a href="#TextAnalysis.tf_idf-Tuple{DocumentTermMatrix}"><code>tf_idf</code></a>, <a href="#TextAnalysis.tf_idf!-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tf_idf.jl#L172-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.timestamp!-Tuple{AbstractDocument,AbstractString}" href="#TextAnalysis.timestamp!-Tuple{AbstractDocument,AbstractString}"><code>TextAnalysis.timestamp!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">timestamp!(doc, timestamp::AbstractString)</code></pre><p>Set the timestamp metadata of doc to <code>timestamp</code>.</p><p>See also: <a href="#TextAnalysis.timestamp-Tuple{AbstractDocument}"><code>timestamp</code></a>, <a href="#TextAnalysis.timestamps-Tuple{Corpus}"><code>timestamps</code></a>, <a href="#TextAnalysis.timestamps!-Tuple{Corpus,Array{String,1}}"><code>timestamps!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L83-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.timestamp-Tuple{AbstractDocument}" href="#TextAnalysis.timestamp-Tuple{AbstractDocument}"><code>TextAnalysis.timestamp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">timestamp(doc)</code></pre><p>Return the timestamp metadata for <code>doc</code>.</p><p>See also: <a href="#TextAnalysis.timestamp!-Tuple{AbstractDocument,AbstractString}"><code>timestamp!</code></a>, <a href="#TextAnalysis.timestamps-Tuple{Corpus}"><code>timestamps</code></a>, <a href="#TextAnalysis.timestamps!-Tuple{Corpus,Array{String,1}}"><code>timestamps!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L30-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.timestamps!-Tuple{Corpus,Array{String,1}}" href="#TextAnalysis.timestamps!-Tuple{Corpus,Array{String,1}}"><code>TextAnalysis.timestamps!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">timestamps!(crps, times::Vector{String})
timestamps!(crps, time::AbstractString)</code></pre><p>Set the timestamps of the documents in <code>crps</code> to the timestamps in <code>times</code>, respectively.</p><p>See also: <a href="#TextAnalysis.timestamps-Tuple{Corpus}"><code>timestamps</code></a>, <a href="#TextAnalysis.timestamp!-Tuple{AbstractDocument,AbstractString}"><code>timestamp!</code></a>, <a href="#TextAnalysis.timestamp-Tuple{AbstractDocument}"><code>timestamp</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L185-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.timestamps-Tuple{Corpus}" href="#TextAnalysis.timestamps-Tuple{Corpus}"><code>TextAnalysis.timestamps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">timestamps(crps)</code></pre><p>Return the timestamps for each document in <code>crps</code>.</p><p>See also: <a href="#TextAnalysis.timestamps!-Tuple{Corpus,Array{String,1}}"><code>timestamps!</code></a>, <a href="#TextAnalysis.timestamp-Tuple{AbstractDocument}"><code>timestamp</code></a>, <a href="#TextAnalysis.timestamp!-Tuple{AbstractDocument,AbstractString}"><code>timestamp!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L122-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.title!-Tuple{AbstractDocument,AbstractString}" href="#TextAnalysis.title!-Tuple{AbstractDocument,AbstractString}"><code>TextAnalysis.title!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">title!(doc, str)</code></pre><p>Set the title of <code>doc</code> to <code>str</code>.</p><p>See also: <a href="#TextAnalysis.title-Tuple{AbstractDocument}"><code>title</code></a>, <a href="#TextAnalysis.titles-Tuple{Corpus}"><code>titles</code></a>, <a href="#TextAnalysis.titles!-Tuple{Corpus,Array{String,1}}"><code>titles!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L40-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.title-Tuple{AbstractDocument}" href="#TextAnalysis.title-Tuple{AbstractDocument}"><code>TextAnalysis.title</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">title(doc)</code></pre><p>Return the title metadata for <code>doc</code>.</p><p>See also: <a href="#TextAnalysis.title!-Tuple{AbstractDocument,AbstractString}"><code>title!</code></a>, <a href="#TextAnalysis.titles-Tuple{Corpus}"><code>titles</code></a>, <a href="#TextAnalysis.titles!-Tuple{Corpus,Array{String,1}}"><code>titles!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.titles!-Tuple{Corpus,Array{String,1}}" href="#TextAnalysis.titles!-Tuple{Corpus,Array{String,1}}"><code>TextAnalysis.titles!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">titles!(crps, vec::Vector{String})
titles!(crps, str)</code></pre><p>Update titles of the documents in a Corpus.</p><p>If the input is a String, set the same title for all documents. If the input is a vector, set title of <code>i</code>th document to corresponding <code>i</code>th element in the vector <code>vec</code>. In the latter case, the number of documents must equal the length of vector.</p><p>See also: <a href="#TextAnalysis.titles-Tuple{Corpus}"><code>titles</code></a>, <a href="#TextAnalysis.title!-Tuple{AbstractDocument,AbstractString}"><code>title!</code></a>, <a href="#TextAnalysis.title-Tuple{AbstractDocument}"><code>title</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L136-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.titles-Tuple{Corpus}" href="#TextAnalysis.titles-Tuple{Corpus}"><code>TextAnalysis.titles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">titles(crps)</code></pre><p>Return the titles for each document in <code>crps</code>.</p><p>See also: <a href="#TextAnalysis.titles!-Tuple{Corpus,Array{String,1}}"><code>titles!</code></a>, <a href="#TextAnalysis.title-Tuple{AbstractDocument}"><code>title</code></a>, <a href="#TextAnalysis.title!-Tuple{AbstractDocument,AbstractString}"><code>title!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/metadata.jl#L95-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tokens-Tuple{Union{FileDocument, StringDocument}}" href="#TextAnalysis.tokens-Tuple{Union{FileDocument, StringDocument}}"><code>TextAnalysis.tokens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tokens(d::TokenDocument)
tokens(d::(Union{FileDocument, StringDocument}))</code></pre><p>Access the document text as a token array.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...

julia&gt; tokens(sd)
7-element Array{String,1}:
    &quot;To&quot;
    &quot;be&quot;
    &quot;or&quot;
    &quot;not&quot;
    &quot;to&quot;
    &quot;be..&quot;
    &quot;.&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L237-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.update-Tuple{TextAnalysis.AveragePerceptron,Any,Any,Any}" href="#TextAnalysis.update-Tuple{TextAnalysis.AveragePerceptron,Any,Any,Any}"><code>TextAnalysis.update</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Applying the perceptron learning algorithm Increment the truth weights and decrementing the guess weights, if the guess is wrong</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L75-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.viterbi_decode-Tuple{CRF,Any,Any}" href="#TextAnalysis.viterbi_decode-Tuple{CRF,Any,Any}"><code>TextAnalysis.viterbi_decode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">viterbi_decode(::CRF, input_sequence)</code></pre><p>Predicts the most probable label sequence of <code>input_sequence</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/predict.jl#L57-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.CRF" href="#TextAnalysis.CRF"><code>TextAnalysis.CRF</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Linear Chain - CRF Layer.</p><p>For input sequence <code>x</code>, predicts the most probable tag sequence <code>y</code>, over the set of all possible tagging sequences <code>Y</code>.</p><p>In this CRF, two kinds of potentials are defined, emission and Transition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/crf.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.CRF-Tuple{Integer}" href="#TextAnalysis.CRF-Tuple{Integer}"><code>TextAnalysis.CRF</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Second last index for start tag, last one for stop tag .</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/crf.jl#L16-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.CooMatrix" href="#TextAnalysis.CooMatrix"><code>TextAnalysis.CooMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Basic Co-occurrence Matrix (COOM) type.</p><p><strong>Fields</strong></p><ul><li><code>coom::SparseMatriCSC{T,Int}</code> the actual COOM; elements represent</li></ul><p>co-occurrences of two terms within a given window</p><ul><li><code>terms::Vector{String}</code> a list of terms that represent the lexicon of</li></ul><p>the document or corpus</p><ul><li><code>column_indices::OrderedDict{String, Int}</code> a map between the <code>terms</code> and the</li></ul><p>columns of the co-occurrence matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/coom.jl#L63-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.CooMatrix-Union{Tuple{T}, Tuple{Corpus,Array{String,1}}} where T&lt;:AbstractFloat" href="#TextAnalysis.CooMatrix-Union{Tuple{T}, Tuple{Corpus,Array{String,1}}} where T&lt;:AbstractFloat"><code>TextAnalysis.CooMatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">CooMatrix{T}(crps::Corpus [,terms] [;window=5, normalize=true])</code></pre><p>Auxiliary constructor(s) of the <code>CooMatrix</code> type. The type <code>T</code> has to be a subtype of <code>AbstractFloat</code>. The constructor(s) requires a corpus <code>crps</code> and a <code>terms</code> structure representing the lexicon of the corpus. The latter can be a <code>Vector{String}</code>, an <code>AbstractDict</code> where the keys are the lexicon, or can be omitted, in which case the <code>lexicon</code> field of the corpus is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/coom.jl#L80-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.Corpus-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractDocument" href="#TextAnalysis.Corpus-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:AbstractDocument"><code>TextAnalysis.Corpus</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Corpus(docs::Vector{T}) where {T &lt;: AbstractDocument}</code></pre><p>Collections of documents are represented using the Corpus type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;Document 1&quot;),
		              StringDocument(&quot;Document 2&quot;)])
A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/corpus.jl#L9-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.DocumentTermMatrix-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T" href="#TextAnalysis.DocumentTermMatrix-Union{Tuple{T}, Tuple{Corpus,Array{T,1}}} where T"><code>TextAnalysis.DocumentTermMatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DocumentTermMatrix(crps::Corpus)
DocumentTermMatrix(crps::Corpus, terms::Vector{String})
DocumentTermMatrix(crps::Corpus, lex::AbstractDict)
DocumentTermMatrix(dtm::SparseMatrixCSC{Int, Int},terms::Vector{String})</code></pre><p>Represent documents as a matrix of word counts.</p><p>Allow us to apply linear algebra operations and statistical techniques. Need to update lexicon before use.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; m = DocumentTermMatrix(crps)
A 2 X 6 DocumentTermMatrix

julia&gt; m.dtm
2×6 SparseArrays.SparseMatrixCSC{Int64,Int64} with 10 stored entries:
  [1, 1]  =  1
  [2, 1]  =  1
  [1, 2]  =  2
  [2, 3]  =  2
  [1, 4]  =  1
  [2, 4]  =  1
  [1, 5]  =  1
  [2, 5]  =  1
  [1, 6]  =  1
  [2, 6]  =  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L22-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.FileDocument-Tuple{AbstractString}" href="#TextAnalysis.FileDocument-Tuple{AbstractString}"><code>TextAnalysis.FileDocument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">FileDocument(pathname::AbstractString)</code></pre><p>Represents a document using a plain text file on disk.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; pathname = &quot;/usr/share/dict/words&quot;
&quot;/usr/share/dict/words&quot;

julia&gt; fd = FileDocument(pathname)
A FileDocument
 * Language: Languages.English()
 * Title: /usr/share/dict/words
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: A A&#39;s AMD AMD&#39;s AOL AOL&#39;s Aachen Aachen&#39;s Aaliyah</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L48-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.KneserNeyInterpolated-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}, Tuple{Array{T,1},Any,Any,Any}} where T&lt;:AbstractString" href="#TextAnalysis.KneserNeyInterpolated-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}, Tuple{Array{T,1},Any,Any,Any}} where T&lt;:AbstractString"><code>TextAnalysis.KneserNeyInterpolated</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">KneserNeyInterpolated(word::Vector{T}, discount:: Float64,unk_cutoff=1, unk_label=&quot;&lt;unk&gt;&quot;) where {T &lt;: AbstractString}</code></pre><p>Initiate Type for providing KneserNey Interpolated language model.</p><p>The idea to abstract this comes from Chen &amp; Goodman 1995.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L211-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.Laplace" href="#TextAnalysis.Laplace"><code>TextAnalysis.Laplace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Laplace(word::Vector{T}, unk_cutoff=1, unk_label=&quot;&lt;unk&gt;&quot;) where {T &lt;: AbstractString}</code></pre><p>Function to initiate Type(Laplace) for providing Laplace-smoothed scores.</p><p>In addition to initialization arguments from BaseNgramModel also requires a number by which to increase the counts, gamma = 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L54-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.Lidstone-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}, Tuple{Array{T,1},Any,Any,Any}} where T&lt;:AbstractString" href="#TextAnalysis.Lidstone-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}, Tuple{Array{T,1},Any,Any,Any}} where T&lt;:AbstractString"><code>TextAnalysis.Lidstone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Lidstone(word::Vector{T}, gamma:: Float64, unk_cutoff=1, unk_label=&quot;&lt;unk&gt;&quot;) where {T &lt;: AbstractString}</code></pre><p>Function to initiate Type(Lidstone) for providing Lidstone-smoothed scores.</p><p>In addition to initialization arguments from BaseNgramModel also requires  a number by which to increase the counts, gamma.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L36-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.MLE-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}} where T&lt;:AbstractString" href="#TextAnalysis.MLE-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}} where T&lt;:AbstractString"><code>TextAnalysis.MLE</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">MLE(word::Vector{T}, unk_cutoff=1, unk_label=&quot;&lt;unk&gt;&quot;) where {T &lt;: AbstractString}</code></pre><p>Initiate Type for providing MLE ngram model scores.</p><p>Implementation of Base Ngram Model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L13-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.NGramDocument-Tuple{AbstractString,TextAnalysis.DocumentMetadata,Vararg{Integer,N} where N}" href="#TextAnalysis.NGramDocument-Tuple{AbstractString,TextAnalysis.DocumentMetadata,Vararg{Integer,N} where N}"><code>TextAnalysis.NGramDocument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">NGramDocument(txt::AbstractString, n::Integer=1)
NGramDocument(txt::AbstractString, dm::DocumentMetadata, n::Integer=1)
NGramDocument(ng::Dict{T, Int}, n::Integer=1) where T &lt;: AbstractString</code></pre><p>Represents a document as a bag of n-grams, which are UTF8 n-grams and map to counts.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; my_ngrams = Dict{String, Int}(&quot;To&quot; =&gt; 1, &quot;be&quot; =&gt; 2,
                                     &quot;or&quot; =&gt; 1, &quot;not&quot; =&gt; 1,
                                     &quot;to&quot; =&gt; 1, &quot;be...&quot; =&gt; 1)
Dict{String,Int64} with 6 entries:
  &quot;or&quot;    =&gt; 1
  &quot;be...&quot; =&gt; 1
  &quot;not&quot;   =&gt; 1
  &quot;to&quot;    =&gt; 1
  &quot;To&quot;    =&gt; 1
  &quot;be&quot;    =&gt; 2

julia&gt; ngd = NGramDocument(my_ngrams)
A NGramDocument{AbstractString}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L148-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.NaiveBayesClassifier-Tuple{Any,Any}" href="#TextAnalysis.NaiveBayesClassifier-Tuple{Any,Any}"><code>TextAnalysis.NaiveBayesClassifier</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">NaiveBayesClassifier([dict, ]classes)</code></pre><p>A Naive Bayes Classifier for classifying documents.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using TextAnalysis: NaiveBayesClassifier, fit!, predict
julia&gt; m = NaiveBayesClassifier([:spam, :non_spam])
NaiveBayesClassifier{Symbol}(String[], Symbol[:spam, :non_spam], Array{Int64}(0,2))

julia&gt; fit!(m, &quot;this is spam&quot;, :spam)
NaiveBayesClassifier{Symbol}([&quot;this&quot;, &quot;is&quot;, &quot;spam&quot;], Symbol[:spam, :non_spam], [2 1; 2 1; 2 1])

julia&gt; fit!(m, &quot;this is not spam&quot;, :non_spam)
NaiveBayesClassifier{Symbol}([&quot;this&quot;, &quot;is&quot;, &quot;spam&quot;, &quot;not&quot;], Symbol[:spam, :non_spam], [2 2; 2 2; 2 2; 1 2])

julia&gt; predict(m, &quot;is this a spam&quot;)
Dict{Symbol,Float64} with 2 entries:
  :spam     =&gt; 0.59883
  :non_spam =&gt; 0.40117</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L41-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.PerceptronTagger" href="#TextAnalysis.PerceptronTagger"><code>TextAnalysis.PerceptronTagger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>PERCEPTRON TAGGER</strong></p><p>This struct contains the POS tagger &quot;PerceptronTagger&quot; which uses model in &quot;AveragePerceptron&quot; In this training can be done and weights can be saved Or a pretrain weights can be used (which are trained on same features) and train more or can be used to predict</p><p><strong>To train:</strong></p><pre><code class="language-julia">julia&gt; tagger = PerceptronTagger(false)

julia&gt; fit!(tagger, [[(&quot;today&quot;,&quot;NN&quot;),(&quot;is&quot;,&quot;VBZ&quot;),(&quot;good&quot;,&quot;JJ&quot;),(&quot;day&quot;,&quot;NN&quot;)]])</code></pre><p><strong>To load pretrain model:</strong></p><pre><code class="language-julia">julia&gt; tagger = PerceptronTagger(true)</code></pre><p><strong>To predict tag:</strong></p><pre><code class="language-julia">julia&gt; predict(tagger, [&quot;today&quot;, &quot;is&quot;])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L130-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.SentimentAnalyzer" href="#TextAnalysis.SentimentAnalyzer"><code>TextAnalysis.SentimentAnalyzer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">model = SentimentAnalyzer()
model(doc)
model(doc, handle_unknown)</code></pre><p>Predict sentiment of the input doc in range 0 to 1, 0 being least sentiment score and 1 being the highest.</p><p><strong>Arguments</strong></p><ul><li>doc              = Input Document for calculating document (<code>AbstractDocument</code> type)</li><li>handle_unknown   = A function for handling unknown words. Should return an array (default x-&gt;tuple())</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/sentiment.jl#L85-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.StringDocument-Tuple{AbstractString}" href="#TextAnalysis.StringDocument-Tuple{AbstractString}"><code>TextAnalysis.StringDocument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">StringDocument(txt::AbstractString)</code></pre><p>Represents a document using a UTF8 String stored in RAM.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; str = &quot;To be or not to be...&quot;
&quot;To be or not to be...&quot;

julia&gt; sd = StringDocument(str)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L79-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.TextHashFunction-Tuple{Int64}" href="#TextAnalysis.TextHashFunction-Tuple{Int64}"><code>TextAnalysis.TextHashFunction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">TextHashFunction(cardinality)
TextHashFunction(hash_function, cardinality)</code></pre><p>The need to create a lexicon before we can construct a document term matrix is often prohibitive. We can often employ a trick that has come to be called the Hash Trick in which we replace terms with their hashed valued using a hash function that outputs integers from 1 to N.</p><p>Parameters: 	-  cardinality	    = Max index used for hashing (default 100)  	-  hash_function    = function used for hashing process (default function present, see code-base)</p><pre><code class="language-julia-repl">julia&gt; h = TextHashFunction(10)
TextHashFunction(hash, 10)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/hash.jl#L26-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.TokenDocument-Tuple{AbstractString,TextAnalysis.DocumentMetadata}" href="#TextAnalysis.TokenDocument-Tuple{AbstractString,TextAnalysis.DocumentMetadata}"><code>TextAnalysis.TokenDocument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">TokenDocument(txt::AbstractString)
TokenDocument(txt::AbstractString, dm::DocumentMetadata)
TokenDocument(tkns::Vector{T}) where T &lt;: AbstractString</code></pre><p>Represents a document as a sequence of UTF8 tokens.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; my_tokens = String[&quot;To&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;, &quot;be...&quot;]
6-element Array{String,1}:
    &quot;To&quot;
    &quot;be&quot;
    &quot;or&quot;
    &quot;not&quot;
    &quot;to&quot;
    &quot;be...&quot;

julia&gt; td = TokenDocument(my_tokens)
A TokenDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L106-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.Vocabulary" href="#TextAnalysis.Vocabulary"><code>TextAnalysis.Vocabulary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Vocabulary(word,unk_cutoff =1 ,unk_label = &quot;&lt;unk&gt;&quot;)</code></pre><p>Stores language model vocabulary. Satisfies two common language modeling requirements for a vocabulary:</p><ul><li>When checking membership and calculating its size, filters items</li></ul><p>by comparing their counts to a cutoff value. Adds a special &quot;unknown&quot; token which unseen words are mapped to.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; words = [&quot;a&quot;, &quot;c&quot;, &quot;-&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;r&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;]
julia&gt; vocabulary = Vocabulary(words, 2) 
  Vocabulary(Dict(&quot;&lt;unk&gt;&quot;=&gt;1,&quot;c&quot;=&gt;3,&quot;a&quot;=&gt;3,&quot;d&quot;=&gt;2), 2, &quot;&lt;unk&gt;&quot;) 

julia&gt; vocabulary.vocab
  Dict{String,Int64} with 4 entries:
   &quot;&lt;unk&gt;&quot; =&gt; 1
   &quot;c&quot;     =&gt; 3
   &quot;a&quot;     =&gt; 3
   &quot;d&quot;     =&gt; 2

Tokens with counts greater than or equal to the cutoff value will
be considered part of the vocabulary.
julia&gt; vocabulary.vocab[&quot;c&quot;]
 3

julia&gt; &quot;c&quot; in keys(vocabulary.vocab)
 true

julia&gt; vocabulary.vocab[&quot;d&quot;]
 2

julia&gt; &quot;d&quot; in keys(vocabulary.vocab)
 true

Tokens with frequency counts less than the cutoff value will be considered not
part of the vocabulary even though their entries in the count dictionary are
preserved.
julia&gt; &quot;b&quot; in keys(vocabulary.vocab)
 false

julia&gt; &quot;&lt;unk&gt;&quot; in keys(vocabulary.vocab)
 true

We can look up words in a vocabulary using its `lookup` method.
&quot;Unseen&quot; words (with counts less than cutoff) are looked up as the unknown label.
If given one word (a string) as an input, this method will return a string.
julia&gt; lookup(&quot;a&quot;)
 &#39;a&#39;

julia&gt; word = [&quot;a&quot;, &quot;-&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]

julia&gt; lookup(vocabulary ,word)
 5-element Array{Any,1}:
  &quot;a&quot;    
  &quot;&lt;unk&gt;&quot;
  &quot;d&quot;    
  &quot;c&quot;    
  &quot;a&quot;

If given a sequence, it will return an Array{Any,1} of the looked up words as shown above.
   
It&#39;s possible to update the counts after the vocabulary has been created.
julia&gt; update(vocabulary,[&quot;b&quot;,&quot;c&quot;,&quot;c&quot;])
 1

julia&gt; vocabulary.vocab[&quot;b&quot;]
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/vocab.jl#L1-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.WittenBellInterpolated-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}} where T&lt;:AbstractString" href="#TextAnalysis.WittenBellInterpolated-Union{Tuple{Array{T,1}}, Tuple{T}, Tuple{Array{T,1},Any}, Tuple{Array{T,1},Any,Any}} where T&lt;:AbstractString"><code>TextAnalysis.WittenBellInterpolated</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">WittenBellInterpolated(word::Vector{T}, unk_cutoff=1, unk_label=&quot;&lt;unk&gt;&quot;) where { T &lt;: AbstractString}</code></pre><p>Initiate Type for providing Interpolated version of Witten-Bell smoothing.</p><p>The idea to abstract this comes from Chen &amp; Goodman 1995.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L134-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis._decode-Tuple{CRF,Any,Any}" href="#TextAnalysis._decode-Tuple{CRF,Any,Any}"><code>TextAnalysis._decode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Computes the forward pass for viterbi algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/predict.jl#L32-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.average_weights-Tuple{TextAnalysis.AveragePerceptron}" href="#TextAnalysis.average_weights-Tuple{TextAnalysis.AveragePerceptron}"><code>TextAnalysis.average_weights</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Averaging the weights over all time stamps</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L106-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.columnindices-Union{Tuple{Array{T,1}}, Tuple{T}} where T" href="#TextAnalysis.columnindices-Union{Tuple{Array{T,1}}, Tuple{T}} where T"><code>TextAnalysis.columnindices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">columnindices(terms::Vector{String})</code></pre><p>Creates a column index lookup dictionary from a vector of terms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/dtm.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.coo_matrix-Union{Tuple{T}, Tuple{Type{T},Array{#s52,1} where #s52&lt;:AbstractString,OrderedDict{#s51,Int64} where #s51&lt;:AbstractString,Int64}, Tuple{Type{T},Array{#s50,1} where #s50&lt;:AbstractString,OrderedDict{#s49,Int64} where #s49&lt;:AbstractString,Int64,Bool}} where T&lt;:AbstractFloat" href="#TextAnalysis.coo_matrix-Union{Tuple{T}, Tuple{Type{T},Array{#s52,1} where #s52&lt;:AbstractString,OrderedDict{#s51,Int64} where #s51&lt;:AbstractString,Int64}, Tuple{Type{T},Array{#s50,1} where #s50&lt;:AbstractString,OrderedDict{#s49,Int64} where #s49&lt;:AbstractString,Int64,Bool}} where T&lt;:AbstractFloat"><code>TextAnalysis.coo_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">coo_matrix(::Type{T}, doc::Vector{AbstractString}, vocab::OrderedDict{AbstractString, Int}, window::Int, normalize::Bool)</code></pre><p>Basic low-level function that calculates the co-occurence matrix of a document. Returns a sparse co-occurence matrix sized <code>n × n</code> where <code>n = length(vocab)</code> with elements of type <code>T</code>. The document <code>doc</code> is represented by a vector of its terms (in order)<code>. The keywords</code>window<code>and</code>normalize` indicate the size of the sliding word window in which co-occurrences are counted and whether to normalize of not the counts by the distance between word positions.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; using TextAnalysis, DataStructures
       doc = StringDocument(&quot;This is a text about an apple. There are many texts about apples.&quot;)
       docv = TextAnalysis.tokenize(language(doc), text(doc))
       vocab = OrderedDict(&quot;This&quot;=&gt;1, &quot;is&quot;=&gt;2, &quot;apple.&quot;=&gt;3)
       TextAnalysis.coo_matrix(Float16, docv, vocab, 5, true)

3×3 SparseArrays.SparseMatrixCSC{Float16,Int64} with 4 stored entries:
  [2, 1]  =  2.0
  [1, 2]  =  2.0
  [3, 2]  =  0.3999
  [2, 3]  =  0.3999</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/coom.jl#L10-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.counter2-Tuple{Any,Integer,Integer}" href="#TextAnalysis.counter2-Tuple{Any,Integer,Integer}"><code>TextAnalysis.counter2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">counter is used to make conditional distribution, which is used by score functions to 
calculate conditonal frequency distribution</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/counter.jl#L3-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.extend!-Tuple{NaiveBayesClassifier,Any}" href="#TextAnalysis.extend!-Tuple{NaiveBayesClassifier,Any}"><code>TextAnalysis.extend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extend!(model::NaiveBayesClassifier, dictElement)</code></pre><p>Add the dictElement to dictionary of the Classifier <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L72-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.features-Tuple{AbstractDict,Any}" href="#TextAnalysis.features-Tuple{AbstractDict,Any}"><code>TextAnalysis.features</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">features(::AbstractDict, dict)</code></pre><p>Compute an Array, mapping the value corresponding to elements of <code>dict</code> to the input <code>AbstractDict</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.fmeasure_lcs" href="#TextAnalysis.fmeasure_lcs"><code>TextAnalysis.fmeasure_lcs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fmeasure_lcs(RLCS, PLCS, β)</code></pre><p>Compute the F-measure based on WLCS.</p><p><strong>Arguments</strong></p><ul><li><code>RLCS</code> - Recall Factor</li><li><code>PLCS</code> - Precision Factor</li><li><code>β</code> - Parameter</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/utils.jl#L91-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.forward_score-Tuple{CRF,Any,Any}" href="#TextAnalysis.forward_score-Tuple{CRF,Any,Any}"><code>TextAnalysis.forward_score</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">forward_score(c::CRF, x::Array)</code></pre><p>Compute the Normalization / partition function or the Forward Algorithm score - <code>Z</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/loss.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.frequencies-Tuple{Any}" href="#TextAnalysis.frequencies-Tuple{Any}"><code>TextAnalysis.frequencies</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create a dict that maps elements in input array to their frequencies.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/bayes.jl#L7-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.getFeatures-Tuple{PerceptronTagger,Any,Any,Any,Any,Any}" href="#TextAnalysis.getFeatures-Tuple{PerceptronTagger,Any,Any,Any,Any,Any}"><code>TextAnalysis.getFeatures</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converting the token into a feature representation, implemented as Dict If the features change, a new model should be trained</p><p><strong>Arguments:</strong></p><ul><li><code>i</code> - index of word(or token) in sentence</li><li><code>word</code> - token</li><li><code>context</code> - array of tokens with starting and ending specifiers</li><li><code>prev</code> == &quot;-START-&quot; prev2 == &quot;-START2-&quot; - Start specifiers</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L226-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.jackknife_avg-Tuple{Any}" href="#TextAnalysis.jackknife_avg-Tuple{Any}"><code>TextAnalysis.jackknife_avg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jackknife_avg(`scores`)</code></pre><p>Apply jackknife on the input list of <code>scores</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/utils.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.log_sum_exp-Tuple{Any}" href="#TextAnalysis.log_sum_exp-Tuple{Any}"><code>TextAnalysis.log_sum_exp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">log_sum_exp(z::Array)</code></pre><p>A stable implementation f(x) = log ∘ sum ∘ exp (x). Since exponentiation can lead to very large numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/crf_utils.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.makeTagDict-Tuple{PerceptronTagger,Any}" href="#TextAnalysis.makeTagDict-Tuple{PerceptronTagger,Any}"><code>TextAnalysis.makeTagDict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>makes a dictionary for single-tag words params : sentences - an array of tuples which contains word and correspinding tag</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L185-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.ngramize-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1},Vararg{Integer,N} where N}} where T&lt;:AbstractString where S&lt;:Languages.Language" href="#TextAnalysis.ngramize-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1},Vararg{Integer,N} where N}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>TextAnalysis.ngramize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ngramize(lang, tokens, n)</code></pre><p>Compute the ngrams of <code>tokens</code> of the order <code>n</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ngramize(Languages.English(), [&quot;To&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;], 3)
Dict{AbstractString,Int64} with 3 entries:
  &quot;be or not&quot; =&gt; 1
  &quot;or not to&quot; =&gt; 1
  &quot;To be or&quot;  =&gt; 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/ngramizer.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.ngramizenew-Union{Tuple{T}, Tuple{Array{T,1},Vararg{Integer,N} where N}} where T&lt;:AbstractString" href="#TextAnalysis.ngramizenew-Union{Tuple{T}, Tuple{Array{T,1},Vararg{Integer,N} where N}} where T&lt;:AbstractString"><code>TextAnalysis.ngramizenew</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ngramizenew( words::Vector{T}, nlist::Integer...) where { T &lt;: AbstractString}</code></pre><p>ngramizenew is used to out putting ngrmas in set</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; seq=[&quot;To&quot;,&quot;be&quot;,&quot;or&quot;,&quot;not&quot;,&quot;To&quot;,&quot;not&quot;,&quot;To&quot;,&quot;not&quot;]
julia&gt; ngramizenew(seq ,2)
 7-element Array{Any,1}:
  &quot;To be&quot; 
  &quot;be or&quot; 
  &quot;or not&quot;
  &quot;not To&quot;
  &quot;To not&quot;
  &quot;not To&quot;
  &quot;To not&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/preprocessing.jl#L69-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.normalize-Tuple{Any}" href="#TextAnalysis.normalize-Tuple{Any}"><code>TextAnalysis.normalize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function is used to normalize the given word params : word - String</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L209-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.onegramize-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1}}} where T&lt;:AbstractString where S&lt;:Languages.Language" href="#TextAnalysis.onegramize-Union{Tuple{T}, Tuple{S}, Tuple{S,Array{T,1}}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>TextAnalysis.onegramize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">onegramize(lang, tokens)</code></pre><p>Create the unigrams dict for input tokens.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; onegramize(Languages.English(), [&quot;To&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;, &quot;be&quot;])
Dict{String,Int64} with 5 entries:
  &quot;or&quot;  =&gt; 1
  &quot;not&quot; =&gt; 1
  &quot;to&quot;  =&gt; 1
  &quot;To&quot;  =&gt; 1
  &quot;be&quot;  =&gt; 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/ngramizer.jl#L34-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.preds_first-Tuple{CRF,Any}" href="#TextAnalysis.preds_first-Tuple{CRF,Any}"><code>TextAnalysis.preds_first</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scores for the first tag in the tagging sequence.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/predict.jl#L4-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.preds_last-Tuple{CRF,Any}" href="#TextAnalysis.preds_last-Tuple{CRF,Any}"><code>TextAnalysis.preds_last</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scores for the last tag in the tagging sequence.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/predict.jl#L11-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.preds_single-Tuple{CRF,Any,Any}" href="#TextAnalysis.preds_single-Tuple{CRF,Any,Any}"><code>TextAnalysis.preds_single</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Scores for the tags other than the starting one.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/predict.jl#L18-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.prob" href="#TextAnalysis.prob"><code>TextAnalysis.prob</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>To get probability of word given that context</p><p>In otherwords, for given context calculate frequency distribution of word</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/LM/langmodel.jl#L96-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_whitespace!-Tuple{StringDocument}" href="#TextAnalysis.remove_whitespace!-Tuple{StringDocument}"><code>TextAnalysis.remove_whitespace!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_whitespace!(doc)
remove_whitespace!(crps)</code></pre><p>Squash multiple whitespaces to a single space and remove all leading and trailing whitespaces in document or crps. Does no-op for <code>FileDocument</code>, <code>TokenDocument</code> or <code>NGramDocument</code>. See also: <a href="#TextAnalysis.remove_whitespace-Tuple{AbstractString}"><code>remove_whitespace</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L447-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.remove_whitespace-Tuple{AbstractString}" href="#TextAnalysis.remove_whitespace-Tuple{AbstractString}"><code>TextAnalysis.remove_whitespace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">remove_whitespace(str)</code></pre><p>Squash multiple whitespaces to a single one. And remove all leading and trailing whitespaces. See also: <a href="#TextAnalysis.remove_whitespace!-Tuple{StringDocument}"><code>remove_whitespace!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/preprocessing.jl#L438-L443">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.score_sequence-Tuple{CRF,Any,Any}" href="#TextAnalysis.score_sequence-Tuple{CRF,Any,Any}"><code>TextAnalysis.score_sequence</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">score_sequence(c::CRF, xs, label_seq)</code></pre><p>Calculating the score of the desired <code>label_seq</code> against sequence <code>xs</code>. Not exponentiated as required for negative log likelihood, thereby preventing operation.</p><p><code>label_seq</code>&lt;:Array/ CuArray eltype(label_seq) = Flux.OneHotVector</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/CRF/loss.jl#L17-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.sentence_tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language" href="#TextAnalysis.sentence_tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>TextAnalysis.sentence_tokenize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sentence_tokenize(language, str)</code></pre><p>Split <code>str</code> into sentences.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sentence_tokenize(Languages.English(), &quot;Here are few words! I am Foo Bar.&quot;)
2-element Array{SubString{String},1}:
 &quot;Here are few words!&quot;
 &quot;I am Foo Bar.&quot;</code></pre><p>See also: <a href="#TextAnalysis.tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>tokenize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tokenizer.jl#L22-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.stemmer_for_document-Tuple{AbstractDocument}" href="#TextAnalysis.stemmer_for_document-Tuple{AbstractDocument}"><code>TextAnalysis.stemmer_for_document</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stemmer_for_document(doc)</code></pre><p>Search for an appropriate stemmer based on the language of the document.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/stemmer.jl#L100-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language" href="#TextAnalysis.tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>TextAnalysis.tokenize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tokenize(language, str)</code></pre><p>Split <code>str</code> into words and other tokens such as punctuation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tokenize(Languages.English(), &quot;Too foo words!&quot;)
4-element Array{String,1}:
 &quot;Too&quot;
 &quot;foo&quot;
 &quot;words&quot;
 &quot;!&quot;</code></pre><p>See also: <a href="#TextAnalysis.sentence_tokenize-Union{Tuple{T}, Tuple{S}, Tuple{S,T}} where T&lt;:AbstractString where S&lt;:Languages.Language"><code>sentence_tokenize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/tokenizer.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.weighted_lcs" href="#TextAnalysis.weighted_lcs"><code>TextAnalysis.weighted_lcs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weighted_lcs(X, Y, weight_score::Bool, returns_string::Bool, weigthing_function::Function)</code></pre><p>Compute the Weighted Longest Common Subsequence of X and Y.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/utils.jl#L26-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.AveragePerceptron" href="#TextAnalysis.AveragePerceptron"><code>TextAnalysis.AveragePerceptron</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This file contains the Average Perceptron model and Perceptron Tagger which was original implemented by Matthew Honnibal.</p><p>The model learns by basic perceptron algorithm but after all iterations weights are being averaged</p><p>AVERAGE PERCEPTRON MODEL</p><p>This struct contains the actual Average Perceptron Model</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/averagePerceptronTagger.jl#L24-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextAnalysis.DocumentMetadata-Tuple{}" href="#TextAnalysis.DocumentMetadata-Tuple{}"><code>TextAnalysis.DocumentMetadata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">DocumentMetadata(language, title::String, author::String, timestamp::String)</code></pre><p>Stores basic metadata about Document.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>language</code>: What language is the document in? Defaults to Languages.English(), a Language instance defined by the Languages package.</li><li><code>title::String</code> : What is the title of the document? Defaults to &quot;Untitled Document&quot;.</li><li><code>author::String</code> : Who wrote the document? Defaults to &quot;Unknown Author&quot;.</li><li><code>timestamp::String</code> : When was the document written? Defaults to &quot;Unknown Time&quot;.</li></ul><p>...</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/f9d0fefe08f1b427459b1a8806f9c0155cf7208c/src/document.jl#L14-L26">source</a></section><footer><hr/><a class="previous" href="../LM/"><span class="direction">Previous</span><span class="title">Statistical Language Model</span></a></footer></article></body></html>
